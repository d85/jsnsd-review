# JSNSD Review

Kill app running on port 3000

```sh
fuser -k 3000/tcp
```

### Execute node command from terminal

```sh
node -e "fs.mkdirSync('http-web-server')"
```

## Ch03 - Creating a Web Server

The `app.use` method takes a function which is called for every incoming request, and it will be passed a request object and a response object.

app.js
```js
'use strict'
const express = require('express')
const createError = require('http-errors')
const indexRoutes = require('./routes')
const helloRoutes = require('./routes/hello')

const app = express()

app.use('/', indexRoutes)
app.use('/hello', helloRoutes)

app.use((req, res, next) => {
  if (req.method !== 'GET') {
    next(createError(405))
    return
  }
  next(createError(404))
})

app.use((err, req, res, next) => {
  res.status(err.status || 500)
  res.send(err.message)
})

module.exports = app
```

routes/index.js
```js
'use strict'
const { Router } = require('express')
const router = Router()

const root = `<html>
  <head>
    <style>
      body { background: #333; margin: 1.25rem }
      a { color: yellow; font-size: 2rem; font-family: sans-serif }
    </style>
  </head>
  <body>
    <a href='/hello'>Hello</a>
  </body>
</html>
`

router.get('/', (req, res) => {
  res.send(root)
})

module.exports = router
```

routes/hello.js
```js
'use strict'
const { Router } = require('express')
const router = Router()

const hello = `<html>
  <head>
    <style>
      body { background: #333; margin: 1.25rem }
      h1 { color: #EEE; font-family: sans-serif }
    </style>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>`

router.get('/', (req, res) => {
  res.send(hello)
})

module.exports = router
```

Does the request match the / GET route?

Does the request match the /hello GET route?

Is it not a GET - create 405 (method not allowed) and send to next middleware

Else no route matched - create 404 (not found) and send to next middleware

Last middleware sets the error in the response

If the `next` function is not called, then the request handling ends there and none of the ensuing registered functions are called for that request.

If an object is passed to `res.send` that object would be serialized to JSON and the response Content-Type would automatically be set to `application/json`.

Even though the `req` and `res` objects are generated by the `http` module and have all the of the same functionality, Express decorates the `req` and `res` objects with additional functionality.

Note however - by conflating Node core APIs with Express APIs on the same objects the principle of lease surprise and separation concerns are violated, while also causing performance issues.

## Ch04 - Serving Web Content

Generally speaking, static assets (content that does not change very often) should not be served by Node. Static content should be delivered via a CDN and/or a caching reverse proxy that specializes in static content such as NGINX or Varnish.

Where Node.js shines however, is dynamic content. Using Node.js as a mediator for gathering data from multiple sources and rendering some output is perfect for such an evented language and non-blocking I/O platform.

### Serving Static Content and Templates with Express

The original focus of the Fastify framework was built on RESTful JSON services, whereas Express is more geared towards template rendering (and serving static content).

```sh
npm i -g express-generator@4
```

```sh
express --hbs express-web-server
```

app.js
```js
var createError = require('http-errors');
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var indexRouter = require('./routes/index');
var helloRouter = require('./routes/hello');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'hbs');

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
if (process.env.NODE_ENV !== 'production') {
  app.use(express.static(path.join(__dirname, 'public')));
}

app.use('/', indexRouter);
app.use('/hello', helloRouter);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;
```

views/layout.hbs
```html
<html>
  <head>
    <style>
     body { background: #333; margin: 1.25rem }
     h1 { color: #EEE; font-family: sans-serif }
     a { color: yellow; font-size: 2rem; font-family: sans-serif }
    </style>
  </head>
  <body>
    {{{ body }}}
  </body>
</html>
```

views/index.hbs
```html
<a href='/hello'>Hello</a><br>
<a href='/hello?greeting=Ahoy'>Ahoy</a>
```

views/hello.hbs
```html
<h1>{{ greeting }} World</h1>
```

views/error.hbs
```html
<h1>{{message}}</h1>
<h2>{{error.status}}</h2>
<pre>{{error.stack}}</pre>
```

routes/index.js
```js
var express = require('express');
var router = express.Router();

router.get('/', function(req, res, next) {
  res.render('index');
});

module.exports = router;
```

routes/hello.js
```js
var express = require('express')
var router = express.Router()

router.get('/', function(req, res, next) {
  var greeting = 'greeting' in req.query ? req.query.greeting : 'Hello'
  res.render('hello', { greeting: greeting })
})

module.exports = router
```

## Streaming Content with Express

Express does not have native support for streams in the same way that Fastify does. However Express decorates the native HTTP `IncomingMessage` object (the response object, `res`). The `res` object is a writeable stream, so this means we can essentially roll our own streaming response. However there are some complexities around this. For instance, when one stream is piped to another it will automatically end the destination stream when the source stream has ended. But in the case of an error, we don't want to end the response, we need to instead propagate the error back into Express so it can handle it centrally according to the configuration in `app.js`.

app.js snippet - articlesRouter added
```js 
...
var indexRouter = require('./routes/index');
var helloRouter = require('./routes/hello');
var articlesRouter = require('./routes/articles')
...
app.use('/', indexRouter);
app.use('/hello', helloRouter);
app.use('/articles', articlesRouter);
...

```

routes/articles.js
```js
const express = require('express')
const router = express.Router()
var hnLatestStream = require('hn-latest-stream')
var finished = require('stream').finished

router.get('/', function(req, res, next) {
  const { amount = 10, type = 'html' } = req.query
  
  if (type === 'html') res.type('text/html')
  if (type === 'json') res.type('application/json')

  const stream = hnLatestStream(amount, type)

  stream.pipe(res, {end: false})

  finished(stream, (err) => {
    if (err) {
      next(err)
      return
    }
    res.end()
  })
})

module.exports = router
```

The `stream.pipe(res, {end: false})` line tells the `stream` (the Hacker News stream) to write all data it receives to the `res` object (which is also a stream). The second parameter, an object with a property named `end` prevents the pipe from performing its default behaviour of ending the destination stream `(res)` when the source stream `(stream)` has ended. This is important because without this, if there is an error in the source stream then `res` will be ended before our server can send an appropriate error response.

We use the `finished` function from the core `stream` module to determine when our Hacker News stream (`stream`) has ended. Using `finished` saves a lot of code, otherwise we would have to listen to the `end`, `close` and `error` events.

If there was an error in `stream` the callback will be passed an error object (the `err` parameter).

## Lab note

### 4.1

Use express generator to generate an app with name app

```sh
express --view=hbs app
```

Or, in the current directory
```sh
express --view=hbs .
```

### Note

```js
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
```
This is only used for POST and PUT requests to handle JSON and form data respectively. Extended relates to whether it needs to handle nested objects.

