# JSNSD Review

Kill app running on port 3000

```sh
fuser -k 3000/tcp
```

### Execute node command from terminal

```sh
node -e "fs.mkdirSync('http-web-server')"
```

## Ch03 - Creating a Web Server

The `app.use` method takes a function which is called for every incoming request, and it will be passed a request object and a response object.

app.js
```js
'use strict'
const express = require('express')
const createError = require('http-errors')
const indexRoutes = require('./routes')
const helloRoutes = require('./routes/hello')

const app = express()

app.use('/', indexRoutes)
app.use('/hello', helloRoutes)

app.use((req, res, next) => {
  if (req.method !== 'GET') {
    next(createError(405))
    return
  }
  next(createError(404))
})

app.use((err, req, res, next) => {
  res.status(err.status || 500)
  res.send(err.message)
})

module.exports = app
```

routes/index.js
```js
'use strict'
const { Router } = require('express')
const router = Router()

const root = `<html>
  <head>
    <style>
      body { background: #333; margin: 1.25rem }
      a { color: yellow; font-size: 2rem; font-family: sans-serif }
    </style>
  </head>
  <body>
    <a href='/hello'>Hello</a>
  </body>
</html>
`

router.get('/', (req, res) => {
  res.send(root)
})

module.exports = router
```

routes/hello.js
```js
'use strict'
const { Router } = require('express')
const router = Router()

const hello = `<html>
  <head>
    <style>
      body { background: #333; margin: 1.25rem }
      h1 { color: #EEE; font-family: sans-serif }
    </style>
  </head>
  <body>
    <h1>Hello World</h1>
  </body>
</html>`

router.get('/', (req, res) => {
  res.send(hello)
})

module.exports = router
```

Does the request match the / GET route?

Does the request match the /hello GET route?

Is it not a GET - create 405 (method not allowed) and send to next middleware

Else no route matched - create 404 (not found) and send to next middleware

Last middleware sets the error in the response

If the `next` function is not called, then the request handling ends there and none of the ensuing registered functions are called for that request.

If an object is passed to `res.send` that object would be serialized to JSON and the response Content-Type would automatically be set to `application/json`.

Even though the `req` and `res` objects are generated by the `http` module and have all the of the same functionality, Express decorates the `req` and `res` objects with additional functionality.

Note however - by conflating Node core APIs with Express APIs on the same objects the principle of lease surprise and separation concerns are violated, while also causing performance issues.

## Ch04 - Serving Web Content

Generally speaking, static assets (content that does not change very often) should not be served by Node. Static content should be delivered via a CDN and/or a caching reverse proxy that specializes in static content such as NGINX or Varnish.

Where Node.js shines however, is dynamic content. Using Node.js as a mediator for gathering data from multiple sources and rendering some output is perfect for such an evented language and non-blocking I/O platform.

### Serving Static Content and Templates with Express

The original focus of the Fastify framework was built on RESTful JSON services, whereas Express is more geared towards template rendering (and serving static content).

```sh
npm i -g express-generator@4
```

```sh
express --hbs express-web-server
```

app.js
```js
var createError = require('http-errors');
var express = require('express');
var path = require('path');
var cookieParser = require('cookie-parser');
var logger = require('morgan');

var indexRouter = require('./routes/index');
var helloRouter = require('./routes/hello');

var app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'hbs');

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
if (process.env.NODE_ENV !== 'production') {
  app.use(express.static(path.join(__dirname, 'public')));
}

app.use('/', indexRouter);
app.use('/hello', helloRouter);

// catch 404 and forward to error handler
app.use(function(req, res, next) {
  next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;
```

views/layout.hbs
```html
<html>
  <head>
    <style>
     body { background: #333; margin: 1.25rem }
     h1 { color: #EEE; font-family: sans-serif }
     a { color: yellow; font-size: 2rem; font-family: sans-serif }
    </style>
  </head>
  <body>
    {{{ body }}}
  </body>
</html>
```

views/index.hbs
```html
<a href='/hello'>Hello</a><br>
<a href='/hello?greeting=Ahoy'>Ahoy</a>
```

views/hello.hbs
```html
<h1>{{ greeting }} World</h1>
```

views/error.hbs
```html
<h1>{{message}}</h1>
<h2>{{error.status}}</h2>
<pre>{{error.stack}}</pre>
```

routes/index.js
```js
var express = require('express');
var router = express.Router();

router.get('/', function(req, res, next) {
  res.render('index');
});

module.exports = router;
```

routes/hello.js
```js
var express = require('express')
var router = express.Router()

router.get('/', function(req, res, next) {
  var greeting = 'greeting' in req.query ? req.query.greeting : 'Hello'
  res.render('hello', { greeting: greeting })
})

module.exports = router
```

## Streaming Content with Express

Express does not have native support for streams in the same way that Fastify does. However Express decorates the native HTTP `IncomingMessage` object (the response object, `res`). The `res` object is a writeable stream, so this means we can essentially roll our own streaming response. However there are some complexities around this. For instance, when one stream is piped to another it will automatically end the destination stream when the source stream has ended. But in the case of an error, we don't want to end the response, we need to instead propagate the error back into Express so it can handle it centrally according to the configuration in `app.js`.

app.js snippet - articlesRouter added
```js 
...
var indexRouter = require('./routes/index');
var helloRouter = require('./routes/hello');
var articlesRouter = require('./routes/articles')
...
app.use('/', indexRouter);
app.use('/hello', helloRouter);
app.use('/articles', articlesRouter);
...

```

routes/articles.js
```js
const express = require('express')
const router = express.Router()
var hnLatestStream = require('hn-latest-stream')
var finished = require('stream').finished

router.get('/', function(req, res, next) {
  const { amount = 10, type = 'html' } = req.query
  
  if (type === 'html') res.type('text/html')
  if (type === 'json') res.type('application/json')

  const stream = hnLatestStream(amount, type)

  stream.pipe(res, {end: false})

  finished(stream, (err) => {
    if (err) {
      next(err)
      return
    }
    res.end()
  })
})

module.exports = router
```

The `stream.pipe(res, {end: false})` line tells the `stream` (the Hacker News stream) to write all data it receives to the `res` object (which is also a stream). The second parameter, an object with a property named `end` prevents the pipe from performing its default behaviour of ending the destination stream `(res)` when the source stream `(stream)` has ended. This is important because without this, if there is an error in the source stream then `res` will be ended before our server can send an appropriate error response.

We use the `finished` function from the core `stream` module to determine when our Hacker News stream (`stream`) has ended. Using `finished` saves a lot of code, otherwise we would have to listen to the `end`, `close` and `error` events.

If there was an error in `stream` the callback will be passed an error object (the `err` parameter).

## Lab note

### 4.1

Use express generator to generate an app with name app

```sh
express --view=hbs app
```

Or, in the current directory
```sh
express --view=hbs .
```

### Note

```js
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
```
This is only used for POST and PUT requests to handle JSON and form data respectively. Extended relates to whether it needs to handle nested objects.

## Ch05 - Creating RESTful JSON Services
Implementing a RESTful JSON GET with Express

model.js

```js
'use strict'

function bicycleModel () {
  const db = {
    1: { brand: 'Veloretti', color: 'green' },
    2: { brand: 'Batavus', color: 'yellow' }
  }

  function read (id, cb) {
    if (!(db.hasOwnProperty(id))) {
      const err = Error('not found')
      setImmediate(() => cb(err))
      return
    }
    setImmediate(() => cb(null, db[id]))
  }

  return {
    read
  }
}

module.exports = {
  bicycle: bicycleModel()
}
```

routes/bicycle.js

```js
var express = require('express');
var router = express.Router();
var model = require('../model');

router.get('/:id', function(req, res, next) {
  model.bicycle.read(req.params.id, (err, result) => {
    if (err) {
      if (err.message === 'not found') next();
      else next(err);
    } else {
      res.send(result);
    }
  });

});

module.exports = router;
```

Go to `http://localhost:3000/bicycle/1`

```sh
node -e "http.get('http://localhost:3000/bicycle/1', ({headers}) => console.log(headers))"
```

output
```
{
  'x-powered-by': 'Express',
  'content-type': 'application/json; charset=utf-8',
  'content-length': '37',
  etag: 'W/"25-Dvma4z3F7o9tKd9A0YSAoLghAaA"',
  date: 'Mon, 31 Oct 2022 20:40:45 GMT',
  connection: 'close'
}
```

```sh
node -e "http.get('http://localhost:3000/bicycle/1', ({statusCode}) => console.log(statusCode))"
```

output
```
200
```

```sh
node -e "http.get('http://localhost:3000/bicycle/9', ({statusCode}) => console.log(statusCode))"
```

output
```
404
```

This should output: `404`. For this case the `model.js` `read` function responded with an error with the message 'not found' and the `next` function in the route handler was called without writing anything to the response. This caused Express to move to the next piece of middleware in the `app.js` file which is:

app.js

```js
...
app.use('/bicycle', bicycleRouter);

// HERE - catch 404 and forward to error handler
app.use(function(req, res, next) {
  next(createError(404));
});

// error handler
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;
```

If any route calls the `next` callback without an error a 404 error is generated by this small middleware function in `app.js`. Since this middleware passes this error to its own `next` callback, this will fall through to the error handling middleware in `app.js` which is:

```js
app.use(function(err, req, res, next) {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});
```

While Fastify is geared towards building RESTful services, Express defaults to serving HTML as it was primarily for dynamic content generation. The error handling middleware can be modified to the following to produce a JSON response when errros occur

```js
app.use(function(err, req, res, next) {
  res.status(err.status || 500);
  res.send({
    type: 'error',
    status: err.status,
    message: err.message,
    stack: req.app.get('env') === 'development' ? err.stack : undefined
  });
});

```

Let's try a POST request to a valid GET route and see what happens:

```sh
node -e "http.request('http://localhost:3000/bicycle/1', { method: 'post'}, ({statusCode}) => console.log(statusCode)).end()"
```

For Express the default behavior in this scenario is to respond with a `404` as well, so this will output: `404`.

Finally let's check whether the server responds with a 500 status code for an unknown error. Let's temporarily alter the read function in models.js to look as follows:

```js
function read (id, cb) {
  setImmediate(() => cb(Error()))
}
```

Finally let's check whether the server responds with a 500 status code for an unknown error. Let's temporarily alter the read function in models.js to look as follows:

```js
function read (id, cb) {
  setImmediate(() => cb(Error()))
}
```

```sh
node -e "http.get('http://localhost:3000/bicycle/1', ({statusCode}) => console.log(statusCode))"
```

output
```
500
```

# Ch06 - Implementing POST, PUT and DELETE with Express

model.js
```js
'use strict'

module.exports = {
  bicycle: bicycleModel()
}

function bicycleModel () {
  const db = {
    1: { brand: 'Veloretti', color: 'green' },
    2: { brand: 'Batavus', color: 'yellow' }
  }

  return {
    create, read, update, del, uid
  }

  function uid () {
    return Object.keys(db)
      .sort((a, b) => a - b)
      .map(Number)
      .filter((n) => !isNaN(n))
      .pop() + 1 + ''
  }

  function create (id, data, cb) {
    if (db.hasOwnProperty(id)) {
      const err = Error('resource exists')
      setImmediate(() => cb(err))
      return
    }
    db[id] = data
    setImmediate(() => cb(null, id))
  }

  function read (id, cb) {
    if (!(db.hasOwnProperty(id))) {
      const err = Error('not found')
      setImmediate(() => cb(err))
      return
    }
    setImmediate(() => cb(null, db[id]))
  }

  function update (id, data, cb) {
    if (!(db.hasOwnProperty(id))) {
      const err = Error('not found')
      setImmediate(() => cb(err))
      return
    }
    db[id] = data
    setImmediate(() => cb())
  }

  function del (id, cb) {
    if (!(db.hasOwnProperty(id))) {
      const err = Error('not found')
      setImmediate(() => cb(err))
      return
    }
    delete db[id]
    setImmediate(() => cb())
  }
}
```

routes/bicylcle/index.js
```js
var express = require('express');
var router = express.Router();
var model = require('../model');

router.get('/:id', function(req, res, next) {
  model.bicycle.read(req.params.id, (err, result) => {
    if (err) {
      if (err.message === 'not found') next();
      else next(err);
    } else {
      res.send(result);
    }
  });
});

router.post('/', function(req, res, next) {
  var id = model.bicycle.uid();
  model.bicycle.create(id, req.body.data, (err) => {
    if (err) next(err);
    else res.status(201).send({ id });
  });
});

router.post('/:id/update', function(req, res, next) {
  model.bicycle.update(req.params.id, req.body.data, (err) => {
    if (err) {
      if (err.message === 'not found') next();
      else next(err);
    } else {
      res.status(204).send();
    }
  });
});

router.put('/:id', function(req, res, next) {
  model.bicycle.create(req.params.id, req.body.data, (err) => {
    if (err) {
      if (err.message === 'resource exists') {
        model.bicycle.update(req.params.id, req.body.data, (err) => {
          if (err) next(err);
          else res.status(204).send();
        });
      } else {
        next(err);
      }
    } else {
      res.status(201).send({});
    }
  });
});

router.delete('/:id', function(req, res, next) {
  model.bicycle.del(req.params.id, (err) => {
    if (err) {
      if (err.message === 'not found') next();
      else next(err);
    } else {
      res.status(204).send();
    }
  });
});

module.exports = router;
```

Each of the routes implement exactly the same logic as the routes in our Fastify service but we use callback-style instead of async/await. The reason for this is two-fold. Firstly, it reflects the code styles used in legacy services - and there are many legacy Express services in the wild. Secondly, **using async/await with Express is recommended against.** Express was built before async/await syntax was part of the JavaScript language and as a result it does not always behave as expected.

For instance, the following will cause a memory leaks:
```js
//: WARNING NEVER DO THIS IN EXPRESS
router.get('/foo', async function(req, res, next) {
  throw Error('what happens?');
  res.send('hi'); // <- this is never reached
});
```

This is because Express does not handle the promise rejection that results from throwing in an async function, and therefore the request does not finish (for a while) and continues to hold state. This would be a source of performance, debugging and maintenance issues. Worse, the same scenario can occur without explicitly throwing:

```js
//: WARNING NEVER DO THIS IN EXPRESS
router.get('/foo', async function(req, res, next) {
  res.dend('hi');
});
```

In this case a typo has been made, res.send is intended but it's written as res.dend. Since that method doesn't exist, this will cause an error to be thrown (because undefined is not a function) and will lead to the same scenario. There are ways around this, for instance monkey-patching the framework, or using try/catch blocks in every single route handler and then passing caught errors to the next callback. However both of these approaches can (and likely will) lead to footgun scenarios, technical debt and different forms of bugs - because they rely on hacks and/or depend on understood and enforced conventions across many people.

**In short, use callback-based API's with Express.**

Making a POST request
```sh
node -e "http.request('http://localhost:3000/bicycle', { method: 'post', headers: {'content-type': 'application/json'}}, (res) => res.setEncoding('utf8').once('data', console.log.bind(null, res.statusCode))).end(JSON.stringify({data: {brand: 'Gazelle', color: 'red'}}))"
```

Output
```js
201 {"id":"3"}
```

Checking the entry was added
```sh
node -e "http.get('http://localhost:3000/bicycle/3', (res) => res.setEncoding('utf8').once('data', console.log))"
```

Output
```js
{"brand":"Gazelle","color":"red"}
```

Updating the entry with the same id
```sh
node -e "http.request('http://localhost:3000/bicycle/3/update', { method: 'post', headers: {'content-type': 'application/json'}}, (res) => console.log(res.statusCode)).end(JSON.stringify({data: {brand: 'Ampler', color: 'blue'}}))"
```

Output

```js
204
```

Check the update worked
```sh
node -e "http.get('http://localhost:3000/bicycle/3', (res) => res.setEncoding('utf8').once('data', console.log))"
```

Output
```js
{"brand":"Ampler","color":"blue"}
```

Create a new entry with PUT
```sh
node -e "http.request('http://localhost:3000/bicycle/99', { method: 'put', headers: {'content-type': 'application/json'}}, (res) => console.log(res.statusCode)).end(JSON.stringify({data: {brand: 'VanMoof', color: 'black'}}))"
```

Output
```
201
```

Check it created it
```sh
node -e "http.get('http://localhost:3000/bicycle/99', (res) => res.setEncoding('utf8').once('data', console.log))"
```

Output
```
201
```

Hit the route with different data to update it
```sh
node -e "http.request('http://localhost:3000/bicycle/99', { method: 'put', headers: {'content-type': 'application/json'}}, (res) => console.log(res.statusCode)).end(JSON.stringify({data: {brand: 'Bianchi', color: 'pink'}}))"
```

Output
```
204
```

Check it updated
```sh
node -e "http.get('http://localhost:3000/bicycle/99', (res) => res.setEncoding('utf8').once('data', console.log))"
```

Output
```
{"brand":"Bianchi","color":"pink"}
```

Check DELETE route
```sh
node -e "http.request('http://localhost:3000/bicycle/99', { method: 'delete', headers: {'content-type': 'application/json'}}, (res) => console.log(res.statusCode)).end()"
```

Output
```
204
```

Check it's deleted
```sh
node -e "http.get('http://localhost:3000/bicycle/99', (res) => res.setEncoding('utf8').once('data', console.log))"
```

Output
```js
{"type":"error","status":404,"message":"Not Found","stack":"NotFoundError: Not Found ... }
```